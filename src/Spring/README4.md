# 스프링 부트


DI는 객체 간의 의존 관계를 스프링 컨테이너가 자동으로 연결해주는 기술로, 객체의 생성과 의존성 관리를 외부(스프링 컨테이너)에서 처리합니다. 이로써, 개발자는 높은 수준의 모듈화와 느슨한 결합을 실현할 수 있게 됩니다.
다른 클래스의 변화에 더욱 안전하고 유연하게 대처할 수 있도록 프로그래밍 하기 위하여 약한 결합을 추구
스프링 컨테이너가 웹에서 사용할 수 있는 공통기능에 대한 클래스들을 미리 만들어 주고
우리가 필요한 곳에 의존주입을 해주는 역할
많은 라이브러리들을 안전하게 이용하여 웹애플리케이션을 개발


## DI의 핵심 개념

- 의존성: 한 클래스가 다른 클래스의 인스턴스(객체)를 사용하는 관계를 말합니다. 예를 들어, Car 클래스가 Engine 클래스의 객체를 필요로 할 때, Car는 Engine에 의존한다고 말할 수 있습니다.

- 주입: 의존성을 가지는 객체에 필요한 객체를 외부(스프링 컨테이너)에서 넣어주는 과정입니다. 이를 통해 객체는 필요한 의존성을 자신이 직접 생성하지 않고도 사용할 수 있게 됩니다.

## DI의 장점
- 낮은 결합도: 객체 간의 결합도를 낮춰서 코드의 재사용성을 높이고, 변경에 유연하게 대응할 수 있습니다.
- 유닛 테스트 용이성: 의존성을 외부에서 주입받기 때문에, 테스트 시에 목 객체(Mock Object)나 스텁(Stub) 등을 주입하여 쉽게 테스트할 수 있습니다.
- 코드의 가독성 및 유지보수성 향상: 의존성이 명시적으로 관리되므로, 코드의 흐름을 쉽게 이해하고 유지보수할 수 있습니다.

## DI 구현 방법
스프링에서는 주로 세 가지 방법으로 DI를 구현합니다:

- 생성자 주입(Constructor Injection): 객체 생성 시 생성자를 통해 의존성을 주입합니다. 의존성이 필수적인 경우 선호됩니다.

- 세터 주입(Setter Injection): 객체 생성 후 세터 메소드를 통해 의존성을 주입합니다. 의존성이 선택적인 경우나 변경 가능성이 있는 경우에 유용합니다.

- 필드 주입(Field Injection): 리플렉션을 사용하여 필드에 직접 의존성을 주입합니다. 간편하지만, 유닛 테스트와 코드 재사용성 측면에서는 권장되지 않습니다.

스프링의 DI를 이용하면 개발자는 객체 간의 관계를 쉽게 관리하며, 더 깔끔하고 유연한 코드를 작성할 수 있습니다. 스프링 컨테이너는 @Autowired 어노테이션, XML 설정 파일, Java 기반 설정 클래스 등을 통해 의존성을 관리하고 주입하는 다양한 방법을 제공합니다.




### 스프링프레임워크가 하는 일
자체적으로 객체를 생성 -> 생성된 객체를 관리 -> 필요한 곳으로 객체 주입

### 스프링이 관리하는 객체 : 빈
스프링의 빈 설정은 XML 을 이용하거나, 별도의 클래스를 이용하여 설정

---
### Application Context 와 Bean의 관계
--> 스프링이 빈들을 관리하는 공간
--> @Autowired 되어 있는 곳에 bean 으로 있는지 비교 해보고 있다면 주입해주다.
==> fieid injection : 클래스 필드의 autowired 되어있는거 객체 주입해주는 것


스프링은 필요한 객체를 스프링에서 주입해주기 때문에
개별적으로 클래스를 작성할 떄, 직접 <bean> 태그를 이용하여 등록하면 원하는 곳에서 쉽게
객체를 사용 할 수 있다.

- 스프링프레임워크는 웹이나 데이터베이스와 같이 특정한영역이 아닌 전체 어플리케이션의 구조를 설계할때 사용된다.

jdbc, jpa/hibernate, mybatis

영속성 특성을 가진다.
데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성

- 영속성을 가지지 않는 데이터는 단지 메모리에만 존재하기 때문에 종료하면 사라진다.
- 파일시스템, rdb,ordb를 활용하여 데이터를 영구적으로 저장.

persistence layer
프로그램의 아키텍처에서 데이터의 영속성을 부여해주는 계층

프레젠테이션 계층 : UI
애플리케이션 계층 : Service
비즈니스 논리 계층: Domain
데이터 접근 계층 : persistence



persistence framwork
1) sql mapper
   sql 과 object 필드를 sql 문장으로 직접 db 데이터 다루는 것, mybatis, jdbctempletes
2) orm
   데이터베이스 데이터와 object 필드를 객체를 통해 간접적으로 db 데이터를 다루는 것


===================================
스프링 WEB-MVC 차이점
- Front-Controller 패턴을 이용해서 모든 흐름의 사전/사후 처리를 가능하도록 설계
- 어노테이션을 적극적으로 활용하여 최소한의 코드로 많은 처리를 하도록 설계
- HttpServletRequest/ HttpServletResponse 이용하지 않아도 될만큼 추사화된 방식으로 개발 가능


1. 컨테이너는 객체이기떄문에 자바의 힙영역에 저장된다

2. HttpServletRequest와 HttpServletResponse 객체는 서버에서 static으로 저장되어 있다가 사용할 때만 쓰레드로 fork되어 생성 및 사용 후 제거:
- 부정확합니다. HttpServletRequest와 HttpServletResponse 객체는 각 HTTP 요청이 들어올 때마다 서블릿 컨테이너에 의해 새롭게 생성됩니다. 이들은 static하게 저장되지 않으며, 각 요청에 대해 독립적인 객체가 생성되어 요청 처리 쓰레드에 전달됩니다. 요청 처리가 완료되면, 이 객체들은 가비지 컬렉션 대상이 됩니다.

3. web.xml은 톰캣 서버의 컨테이너다. 즉, 톰캣 컨테이너에 빈 컨테이너와 서블릿 컨테이너를 넣은 구조:
- 부정확합니다. web.xml 파일은 웹 애플리케이션의 설정 파일로, 서블릿 매핑, 리스너, 필터 등 웹 애플리케이션의 구성 요소를 정의합니다. web.xml 자체가 톰캣의 컨테이너는 아니며, 톰캣과 같은 서블릿 컨테이너는 이 파일을 읽어 웹 애플리케이션을 구성하고 관리합니다.

4. JSP 파일은 파일 존재만으로 톰캣 서버에서 클래스 같은 객체로 저장되어 있다:
- 부정확합니다. JSP 파일은 서버에 의해 최초 요청 시 서블릿으로 변환(컴파일)되고, 이 서블릿 클래스가 메모리에 로드되어 실행됩니다. JSP 파일 자체가 객체로 저장되는 것이 아니라, 이를 통해 생성된 서블릿 클래스가 메모리에 존재합니다.

5. 세션데이터는 host 단위로 저장되어서 jsp 끼리 공유가 가능한것이다















