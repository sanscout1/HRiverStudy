# 웹 개발

## 웹 기본 동작
- Request(요청) / Response (응답)

1) Get 방식: 주소창에 직접 원하는 데이터를 적거나 링크를 클릭해서 호출


2) Post 방식: 입력화면에서 필요한 내용을 작성한 후에 전송 같은 버튼을 클릭해서 호출



- 서버는 브라우저로 응답을 보내는데, 서버에서는 요청 내용이 정적데이터인지, 동적데이터인지에 따라 다르게 처리한다.

- 정적데이터를 처리하는 서버 : 웹서버가 담당
-  처리하는 서버: WAS 웹애플리케이션 서버
- 우리가 채택한 WAS : Tomcat -- (웹서버 + 웹 컨테이너)

- 서버 사이드 프로그래밍 : 동적으로 상황에 맞도록 서버에서 데이터를 만들어 보내는 방식

```
동시에 여러 요청이 들어온다면 어떻게 처리할까
서버에서 문제가 생기면 어떻게 처리할까
어떤 방법으로 데이터 전송을 최적화 할 수 있을까
분산 환경이나 분산처리와 같은 문제점이 무엇이 있고 이를 해결하기 위한 방법은?
```
## J2EE
- Servlet 기술

- 스프링 부트(Spring Boot)에서 서블릿은 웹 애플리케이션의 기본적인 빌딩 블록으로 사용됩니다. 스프링 부트는 스프링 프레임워크를 기반으로 하며, 이는 서블릿 API 위에서 구축되었습니다. 스프링 부트는 내장된 서블릿 컨테이너(예: Tomcat, Jetty, Undertow)를 사용하여 웹 애플리케이션을 쉽게 개발, 패키징, 실행할 수 있도록 설계되었습니다. 이러한 내장 서블릿 컨테이너 덕분에, 개발자는 복잡한 서버 구성 없이도 스프링 부트 애플리케이션을 실행할 수 있습니다.
### 스프링 부트에서 서블릿의 역할은 다음과 같습니다:
- HTTP 요청 처리: 서블릿은 클라이언트(브라우저)로부터 오는 HTTP 요청을 받아 처리하고, 적절한 HTTP 응답을 생성하여 반환합니다. 스프링 부트에서는 @Controller나 @RestController 어노테이션이 붙은 클래스가 이 역할을 수행하며, 내부적으로는 서블릿 API를 사용하여 요청을 처리합니다.
- 스프링 MVC 통합: 스프링 부트는 스프링 MVC(모델-뷰-컨트롤러) 웹 프레임워크와 통합되어 있습니다. 스프링 MVC는 서블릿 API 위에서 동작하며, 컨트롤러를 통해 HTTP 요청을 처리합니다. 스프링 부트는 스프링 MVC를 쉽게 설정하고 사용할 수 있도록 도와줍니다.
- 웹 애플리케이션의 자동 구성: 스프링 부트는 spring-boot-autoconfigure 모듈을 통해 웹 애플리케이션에 필요한 서블릿 컨테이너 및 다른 웹 관련 설정을 자동으로 구성합니다. 이는 개발자가 복잡한 설정 작업 없이도 웹 애플리케이션을 빠르게 시작할 수 있게 해줍니다.
- 필터(Filter)와 리스너(Listener) 지원: 스프링 부트는 서블릿 필터와 리스너를 등록하여 HTTP 요청/응답 사이클에 개입하고, 애플리케이션의 이벤트를 처리할 수 있도록 지원합니다. 이를 통해 보안, 로깅, 요청 사전 처리 등의 기능을 구현할 수 있습니다.
#### 요약하자면, 스프링 부트에서 서블릿은 웹 애플리케이션의 핵심적인 부분으로, HTTP 요청을 처리하고, 스프링 MVC와의 통합, 웹 애플리케이션의 자동 구성 등을 담당합니다. 스프링 부트는 이 모든 것을 보다 쉽고 효율적으로 관리할 수 있도록 해줍니다




- 빈 컨테이너에서의 관리: 스프링 부트 애플리케이션을 시작할 때, 스프링 IoC(Inversion of Control) 컨테이너는 @Controller나 @RestController와 같은 애너테이션이 붙은 클래스를 스캔하고, 이들을 빈으로 등록합니다. 이 과정에서 각 컨트롤러 빈의 생성, 의존성 주입, 그리고 관리(생명주기 포함)가 이루어집니다.
- 서블릿 컨테이너와 DispatcherServlet: 스프링 부트는 내장된 서블릿 컨테이너(예: Tomcat)를 사용하여 웹 요청을 처리합니다. 웹 요청이 들어오면, 서블릿 컨테이너는 이를 스프링의 DispatcherServlet에 전달합니다. DispatcherServlet은 스프링 MVC의 핵심 요소로, 모든 웹 요청을 처음 받아들이는 진입점 역할을 합니다.
- 요청 처리: DispatcherServlet은 요청을 분석하고, 해당 요청을 처리할 수 있는 컨트롤러의 메서드를 결정합니다. 그리고 스프링 IoC 컨테이너에서 관리되는 해당 컨트롤러 빈의 메서드를 호출합니다.
- 뷰 렌더링 및 응답 반환: 컨트롤러 메서드는 처리 결과를 모델(Model)에 담고, 뷰(View) 이름을 반환합니다. DispatcherServlet은 뷰 이름을 바탕으로 실제 뷰 객체를 찾고, 모델 데이터와 함께 뷰를 렌더링합니다. 렌더링된 뷰는 최종적으로 클라이언트에게 응답으로 반환됩니다.
- 생명주기 관리: 컨트롤러의 생성과 소멸 등 생명주기는 스프링 IoC 컨테이너에 의해 관리되지만, 요청 처리 과정 자체는 서블릿 컨테이너와 DispatcherServlet에 의해 처리됩니다. 즉, 서블릿 컨테이너는 요청의 수신과 응답의 전송을 담당하며, 스프링 컨테이너는 애플리케이션의 객체(빈)를 관리합니다.
#### 요약하자면, 스프링 부트에서 컨트롤러는 스프링 IoC 컨테이너에 의해 관리되며, 웹 요청 처리는 내장된 서블릿 컨테이너와 DispatcherServlet을 통해 이루어집니다. 이 두 컨테이너는 각각의 역할에 따라 애플리케이션의 빈 관리와 웹 요청 처리를 담당하며, 함께 작동하여 웹 애플리케이션을 효율적으로 실행합니다.



- 빈 컨테이너 --> 스프링의 빈들을 관리하며 주 역할은 ioc/di 를 통한 빈의 생성, 의존성 주입, 그리고 관리
- 서블릿 컨테이너 --> http 요청에 따라 생성 관리하는 컨테이너


- vo-> db 의 테이블의 칼럼의 값을 도메인 맞게 저장, getter 로만 호출가능
- dto -> dao 레이어의 vo 에서 비즈니스계층의 model 로 원하는 데이터만 전송, 비즈니스계층에서 표현계층으로 전달에서도 사용








## 로그 기능 : Log4j2

- level(레벨) 설정
- lombok 의 경우 @log4j2 를 이용하여 소스 코드 내에 로그 적용 가능

- Log4j2는 다양한 로그 레벨, 로거(Logger), 애펜더(Appender), 필터(Filter) 등을 통해 로그 메시지의 출력, 형식, 저장 방법 등을 세밀하게 제어할 수 있습니다.

- -level(Info)
- Log4j2에서는 로그 메시지의 중요도에 따라 여러 로그 레벨을 제공합니다. 이러한 로그 레벨을 통해 개발자는 로그의 상세 수준을 조정할 수 있으며, 실행 중인 애플리케이션에서 발생하는 다양한 이벤트를 적절히 기록할 수 있습니다. Log4j2의 주요 로그 레벨은 다음과 같습니다:

- FATAL: 가장 심각한 오류를 나타내며, 애플리케이션이 계속 실행될 수 없는 상태입니다.
- ERROR: 예상치 못한 상황에서 발생한 오류로, 애플리케이션의 일부 기능이 제대로 작동하지 않을 때 사용됩니다.
- WARN: 잠재적으로 해로운 상황을 경고할 때 사용됩니다. 오류는 아니지만, 주의가 필요한 상황입니다.
- INFO: 애플리케이션의 일반적인 이벤트를 기록할 때 사용됩니다. 사용자에게 유용한 정보나 상태 업데이트 등에 사용됩니다.
- DEBUG: 개발 과정에서 상세한 실행 정보를 기록할 때 사용됩니다. 문제 해결 및 애플리케이션의 흐름을 추적하는 데 도움이 됩니다.
- TRACE: DEBUG보다 더 상세한 정보를 기록할 때 사용됩니다. 애플리케이션의 거의 모든 실행 경로를 추적할 수 있으며, 문제 해결에 매우 유용합니다.

- 아래가 레벨 제일 낮아서 광범위함

- Appender
로그 메시지를 다양한 목적지(콘솔, 파일, 데이터베이스 등)에 출력하는 역할을 합니다.


로깅처리 위해 @Log4j2   클래스 위에 설정 후  확인하고자 하는 객체 log.info(vo)  형태로 확인합니다.


----------------------------------------------------
## 웹 MVC 구조를 이용하면 어떤 장점,단점이 있는지
- 책임과 역할을 구분해서 작업을 진행 가능
- 여러개의 반복적 코드를 작성해야한다

### 질문)지금 만든 웹MVC 구조를 이용하면 좀 더 확실하게 책임과 역할을 구분해서 작업을 진행할 수 있다는 장점도 존재하지만 여러개의 코드를 만든다는 단점이 존재한다. 좀 더 개선해야 할 부분에 대한 4가지는 무엇일까??

1. 여러 개의 컨트롤러를 작성하는 번거로움
2. 동일한 로직의 반복적인 사용
3. 에외 처리의 부재
4. 반복적인 메소드 호출

1. 스프링부트와 같은 프레임워크를 사용하여 코드의 복잡성을 줄여 개발 과정을 간소화하고, 생산성을 높일 수 있습니다.
2. mvc 패턴에서 사용되는 공통기능들을 모듈로 만들어서 관리합니다. 대표적으로 JPA 를 이용하여 공통 CRUD연산을 줄 일 수 있습니다.
3. 예외처리가 필요합니다



## 스프링 프레임워크 와 비교 하면서 작업
===============================
- 세션, 쿠키, 필터, 리스너 기본개념 이해, 동작원리 이해 활용
- 로그인 처리

```
톰캣 내장 객체
page
request
response
session
application
exception
config
```
=====================
- 웹은 과거의 상태를 유지하지 않는다 (stateless)
- 요청과 응답을 하나의 단위로 처리하면서 기존 사용자의 대한 정보를 기억하지 않는다

- 무상태 특징으로 인해 기존의 방문자를 기억하기 위한 매커니즘 사용
==> 세션(HttpSession), 쿠키(Cookie), JWT
- 로그인 유지를 위한 모든 기능을 세션트래킹

1. 쿠키 : 문자열로 만들어진 데이터의 조각
   서버와 브라우저 사이에서 요청이나 응답 시에 주고받는 형태로 사용
   (name, value)

= 쿠키를 주고받는 시나리오
1. 브라우저가 최초로 서버를 호출하는 경우 해당 서버에서 발행한 쿠키가 없다면 브라우저는 아무것도 전송하지 않는다.
2. 서버에서는 응답메세지를 보낼때 쿠키를 보내준다. (Set-Cookie) HTTP 헤더를 이용
3. 브라우저는 쿠키를 받은 후, 정보를 읽고, 쿠키는 유효기간(만료기간)을 보고 메모리상에 처리할 것인지, 파일로 보관할 것인지 판단한다.
4. 브라우저가 보관하는 쿠키는 다음에 다시 브라우저가 해당 서버에 요청을 보낼때 HTTP 헤더에 Cookie 라는 헤더 이름과 함께 전달한다.
5. 서버에서는 필요에 따라 브라우저가 보낸 쿠키를 읽고 사용한다.


쿠키를 생성하는 방법
1. 서버에서 자동으로 발행 : tomcat JSESSIONID 발행
2. 개발자가 코드로 직접 발행 : response.addCookie( )


* 세션을 이용한 로그인 체크 (쿠키가 세션정보라고 봐도 되는듯)
1. 사용자가 로그인에 성공하면 HttpSession을 이용해서 해당 사용자의 공간(세션 컨텍스트)에
   특정한 객체를 이름과 함께 저장

2. 로그인 체크가 필요한 컨트롤러에서는 현재 사용자의 공간에 지정된 이름(key)으로
   객체가 저장되어 있는지 확인한 후 객체가 존재한다면 해당 사용자는 로그인된
   사용자로 간주하고, 그렇지 않으면 로그인 페이지로 이동시킴

3. 필터를 이용한 로그인 체크
   필터를 이용하여 특정한 서블릿이나 jsp 도달하는 과정에서 필터링하는 역할을 하는 서블릿 API
   @WebFilter 여러개 적용가능
   내가 필터에서 지정한 경로들은 접근할때 필터를 무조건 걸쳐감


!! 세션의 setattribue 하면 세션에 값이 저장되어 오래 오래 jsp 에서 이용가능
request에 setattribute 하면 단기적으로만 사용가능해서 jsp 한쪽에서만 이용가능



## 톰캣

- 톰캣(Tomcat) 서버는 자바 서블릿과 JSP(JavaServer Pages)를 실행하기 위한 웹 컨테이너(Web Container) 또는 서블릿 컨테이너(Servlet Container)입니다. Apache Software Foundation에서 개발했으며, 가벼운 웹 애플리케이션 서버로 널리 사용됩니다. 톰캣은 자바 엔터프라이즈 에디션(Java EE) 스펙의 웹 컴포넌트를 지원하며, HTTP를 통해 클라이언트의 요청을 처리하고, 자바 서블릿을 통해 동적 웹 콘텐츠를 생성합니다.

### 톰캣 서버의 주요 구성 요소:
- 커넥터(Connector): 클라이언트의 요청을 받아들이고 응답을 보내는 역할을 합니다. HTTP, HTTPS, AJP(Apache JServ Protocol) 등 다양한 프로토콜을 지원합니다.

- (Engine): 서블릿의 실행을 담당합니다. 컨텍스트와 호스트를 관리하며, 서블릿 요청을 적절한 웹 애플리케이션으로 라우팅합니다.

- 호스트(Host): 가상 호스팅을 지원합니다. 하나의 엔진이 여러 호스트를 관리할 수 있으며, 각 호스트는 도메인 이름으로 구분됩니다.

- 컨텍스트(Context): 웹 애플리케이션을 의미합니다. 각 컨텍스트는 독립된 웹 애플리케이션으로 작동하며, 자신만의 서블릿 컨텍스트를 가집니다.

- 서블릿 컨테이너(Servlet Container): 서블릿 생명주기를 관리합니다. 클라이언트의 요청을 받으면 적절한 서블릿을 찾아서 실행하고, 서블릿이 생성하는 동적 컨텐츠를 클라이언트에게 전달합니다.

- 세션 관리(Session Management): 사용자의 상태 정보를 관리합니다. HTTP는 상태를 유지하지 않는 프로토콜이므로, 톰캣은 쿠키나 URL 재작성 등의 방법을 사용하여 세션을 관리합니다.

- 보안(Security): 보안 도메인을 구성하여 웹 애플리케이션의 보안을 강화할 수 있습니다. 사용자 인증, 권한 부여 등의 기능을 제공합니다.




### 톰캣 내장 객체는 JSP(JavaServer Pages)에서 사용되는 객체로,
- JSP 페이지가 실행될 때 자동으로 생성되어 여러 기능을 수행하는 데 사용됩니다. 이 객체들을 사용함으로써, 개발자는 클라이언트의 요청 정보를 처리하거나, 응답을 생성하고, 세션 정보를 관리하는 등의 작업을 보다 쉽게 수행할 수 있습니다. 각 내장 객체의 역할은 다음과 같습니다:

- page: 현재 페이지 인스턴스를 참조하는 객체입니다. this 키워드와 유사하게 현재 JSP 페이지 자신을 가리킵니다. 일반적으로 사용 빈도는 낮습니다.

- request: 클라이언트의 요청과 관련된 정보와 데이터를 포함하는 HttpServletRequest 객체입니다. 클라이언트로부터 받은 데이터를 읽거나, 요청 헤더 및 파라미터를 처리하는 데 사용됩니다.

- response: 클라이언트에게 보낼 응답과 관련된 HttpServletResponse 객체입니다. 응답 타입, 쿠키 추가, 리다이렉트 설정 등 응답을 구성하는 데 필요한 메서드를 제공합니다.

- session: 클라이언트의 세션 정보를 관리하는 HttpSession 객체입니다. 사용자별로 유지해야 하는 정보(예: 로그인 상태, 선택한 언어 등)를 서버 측에 저장하고 관리할 때 사용됩니다.

- application: 웹 애플리케이션 전체에서 공유되는 정보를 관리하는 ServletContext 객체입니다. 웹 애플리케이션이 시작될 때 생성되며, 애플리케이션의 모든 사용자 사이에서 공유되는 정보를 저장하거나 애플리케이션 레벨의 이벤트를 처리하는 데 사용됩니다.

- exception: 예외 처리 페이지에서 사용되는 객체로, 현재 페이지에서 발생한 예외에 대한 정보를 포함하는 Throwable 객체입니다. 이 객체는 JSP 페이지가 에러 페이지로 지정됐을 때만 사용 가능합니다.

- config: 현재 JSP 페이지의 서블릿 설정 정보에 접근할 수 있는 ServletConfig 객체입니다. JSP 페이지에 대한 초기화 파라미터 등의 설정 정보를 읽는 데 사용됩니다.


<br>
<br>

- Tomcat 은 Java로 작성된 Program이기 때문에 JVM (Java Virtual Machine) 위에서 동작합니다. 하나의 JVM 에서 하나의 Tomcat Instance (Server)가 하나의 Process 로써 동작합니다.

- 하나의 Server 에는 여러 개의 Service 가 존재할 수 있습니다. 각각의 Service는 1개의 1개의 Engine 과 여러 개의 Connector 로 구성됩니다.

- Engine 은 Catalina Servlet Engine이라고도 불리며, 정의된 Connector로 들어온 요청을 하위에 있는 해당 Host에게 전달해주는 역할을 수행합니다.

- 하나의 Engine 에는 여러 개의 Host 가 존재할 수 있습니다. Host는 가상호스트 이름을 나타내며, 호스트 이름이 곧 url에 매핑됩니다. (ex : http://hostname/ ).

- 하나의 Host 에는 여러 개의 Context 가 존재할 수 있습 니다. Context는 하나의 Web Application을 나타내며 주로 *.war 파일의 형태로 배포가 됩니다.


```
톰캣 서버를 키면 위에 그림 서버 하나 생기고, 서버에 여러 서비스 가동 가능, 서비스당 하나의 엔진만 가질수 있으며,
엔진에는 여러개의 호스트를 만들수 있다
ex) localhost/ 가 하나의 호스트
그리고 그밑에 여러개의 context 생성가능 ex)localhost/todo/list
todo/list 가 context 임
todo/list 같은 jsp 마다 세션저장소가 있어서 세션정보를 저장하고있는것

context ==> web applicate ==> jsp (host마다 session context를 보유하고 있어서 db처럼 session 값을 저장하고 있는다)
```


